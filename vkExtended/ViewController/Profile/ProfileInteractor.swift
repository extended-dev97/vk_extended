//
//  ProfileInteractor.swift
//  vkExtended
//
//  Created Ярослав Стрельников on 26.10.2020.
//  Copyright © 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import Alamofire
import SwiftyJSON

class ProfileInteractor: ProfileInteractorProtocol {

    weak var presenter: ProfilePresenterProtocol?
    private var revealedPostIds = [Int]()
    private var wallResponse: WallResponse?
    private var countOffset: Int = 0

    func start(request: ProfileModel.Request.RequestType) {
        makeRequest(request: request)
    }

    func makeRequest(request: ProfileModel.Request.RequestType) {
        switch request {
        case .getProfile(userId: let userId):
            let parameters: Alamofire.Parameters = [
                Parameter.code.rawValue: "return [API.users.get({\"user_ids\": \"\(userId.stringValue)\", \"fields\": \"\(Constants.userFields)\"}), API.photos.getAll({\"owner_id\": \"\(userId.stringValue)\", \"extended\": \"1\"}), API.friends.get({\"user_id\": \"\(userId.stringValue)\", \"order\": \"hints\", \"count\": \"200\", \"fields\": \"\(Constants.userFields)\"}), API.wall.get({\"owner_id\": \"\(userId.stringValue)\", \"extended\": \"1\", \"fields\": \"\(Constants.userFields)\", \"filter\": \"all\"})];",
            ]
            
            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .execute, with: ApiMethod.Execute.execute, hasExecute: true), parameters: parameters, isExecute: true).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    let json = JSON(data)
                    let encryptedUser = try? json[0].arrayValue.first?.rawData()
                    let encryptedPhotos = try? json[1].rawData()
                    let encryptedFriends = try? json[2].rawData()
                    let encryptedWall = try? json[3].rawData()
                    
                    let decodedUser = decodeJSON(type: ProfileResponse.self, from: encryptedUser)
                    let decodedPhotos = decodeJSON(type: PhotoResponse.self, from: encryptedPhotos)
                    let decodedFriends = decodeJSON(type: FriendResponse.self, from: encryptedFriends)
                    let decodedWall = decodeJSON(type: WallResponse.self, from: encryptedWall)
                    
                    self.presenter?.presentData(response: .presentProfile(profile: decodedUser, photos: decodedPhotos, friends: decodedFriends, wall: decodedWall, revealdedPostId: self.revealedPostIds))
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        case .getProfileInfo(userId: let userId):
            let parameters: Alamofire.Parameters = [
                Parameter.fields.rawValue: Constants.userFields,
                Parameter.userIDs.rawValue: userId
            ]
            
            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .users, with: ApiMethod.Users.get), parameters: parameters).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    if let dataFirstObject: Data = try? JSON(data).arrayValue.first?.rawData() {
                        if let decoded = decodeJSON(type: ProfileResponse.self, from: dataFirstObject) {
                            self.presenter?.presentData(response: .presentProfileInfo(profile: decoded))
                        } else {
                            self.presenter?.presentData(response: .presentFooterError(message: "Ошибка парсинга данных"))
                        }
                    } else {
                        self.presenter?.presentData(response: .presentFooterError(message: "Ошибка данных"))
                    }
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        case .getProfilePhotos(userId: let userId):
            let parameters: Alamofire.Parameters = [
                Parameter.ownerId.rawValue: userId,
                Parameter.count.rawValue: 200,
                Parameter.noServiceAlbums.rawValue: 0,
                Parameter.extended.rawValue: 1
            ]

            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .photos, with: ApiMethod.Photos.getAll), parameters: parameters).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    if let decoded = decodeJSON(type: PhotoResponse.self, from: data) {
                        self.presenter?.presentData(response: .presentProfilePhotos(photos: decoded))
                    } else {
                        self.presenter?.presentData(response: .presentFooterError(message: "Ошибка парсинга данных"))
                    }
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        case .getProfileFriends(userId: let userId):
            let parameters: Alamofire.Parameters = [
                Parameter.fields.rawValue: Constants.userFields,
                Parameter.order.rawValue: "hints",
                Parameter.userId.rawValue: userId,
                Parameter.count.rawValue: 200
            ]
            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .friends, with: ApiMethod.Friends.get), parameters: parameters).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    if let decoded = decodeJSON(type: FriendResponse.self, from: data) {
                        self.presenter?.presentData(response: .presentProfileFriends(friends: decoded))
                    } else {
                        self.presenter?.presentData(response: .presentFooterError(message: "Ошибка парсинга данных"))
                    }
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        case .getProfileWall(let userId):
            self.presenter?.presentData(response: .presentFooterLoader)
            let parameters: Alamofire.Parameters = [
                Parameter.fields.rawValue: Constants.userFields,
                Parameter.filter.rawValue: "all",
                Parameter.ownerId.rawValue: userId,
                Parameter.extended.rawValue: 1
            ]
            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .wall, with: ApiMethod.Wall.get), parameters: parameters).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    if let decoded = decodeJSON(type: WallResponse.self, from: data) {
                        self.wallResponse = decoded
                        self.presenter?.presentData(response: .presentProfileWall(wall: decoded, revealdedPostIds: self.revealedPostIds))
                    } else {
                        self.presenter?.presentData(response: .presentFooterError(message: "Ошибка парсинга данных"))
                    }
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        case .revealPostIds(postId: let postId):
            if revealedPostIds.count > 0 {
                for revealId in revealedPostIds {
                    if revealId != postId {
                        revealedPostIds.append(postId)
                    } else {
                        continue
                    }
                }
            } else {
                revealedPostIds.append(postId)
            }
            guard let wallResponse = wallResponse else { return }
            self.presenter?.presentData(response: .presentProfileWall(wall: wallResponse, revealdedPostIds: revealedPostIds))
        case .getNextBatch(userId: let userId):
            countOffset = wallResponse?.count ?? 0
            self.presenter?.presentData(response: .presentFooterLoader)
            let parameters: Alamofire.Parameters = [
                Parameter.fields.rawValue: Constants.userFields,
                Parameter.filter.rawValue: "all",
                Parameter.offset.rawValue: countOffset,
                Parameter.ownerId.rawValue: userId,
                Parameter.extended.rawValue: 1
            ]
            presenter?.presentData(response: .presentFooterLoader)
            Request.dataRequest(method: ApiMethod.method(from: .newsfeed, with: ApiMethod.NewsFeed.get), parameters: parameters).done { [weak self] response in
                guard let self = self else { return }
                switch response {
                case .success(let data):
                    if let decoded = decodeJSON(type: WallResponse.self, from: data) {
                        guard self.wallResponse?.items.count != decoded.count else { return }
                        if self.wallResponse == nil {
                            self.wallResponse = decoded
                        } else {
                            self.wallResponse?.items.append(contentsOf: decoded.items)
                            
                            var profiles = decoded.profiles
                            if let oldProfiles = self.wallResponse?.profiles {
                                let oldProfilesFiltered = oldProfiles.filter({ (oldProfile) -> Bool in
                                    !decoded.profiles.contains(where: { $0.id == oldProfile.id })
                                })
                                profiles.append(contentsOf: oldProfilesFiltered)
                            }
                            self.wallResponse?.profiles = profiles
                            
                            var groups = decoded.groups
                            if let oldGroups = self.wallResponse?.groups {
                                let oldGroupsFiltered = oldGroups.filter({ (oldGroup) -> Bool in
                                    !decoded.groups.contains(where: { $0.id == oldGroup.id })
                                })
                                groups.append(contentsOf: oldGroupsFiltered)
                            }
                            self.wallResponse?.groups = groups
                        }
                        
                        guard let wallResponse = self.wallResponse else { return }
                        self.presenter?.presentData(response: .presentProfileWall(wall: wallResponse, revealdedPostIds: self.revealedPostIds))
                    } else {
                        self.presenter?.presentData(response: .presentFooterError(message: "Ошибка парсинга данных"))
                    }
                case .error(let error):
                    self.presenter?.presentData(response: .presentFooterError(message: error.toVK().localizedDescription))
                }
                
            }.catch { error in
                self.presenter?.presentData(response: .presentFooterError(message: error.localizedDescription))
            }
        default:
            break
        }
    }
}
