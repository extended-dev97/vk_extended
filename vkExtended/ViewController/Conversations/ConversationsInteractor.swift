//
//  ConversationsInteractor.swift
//  vkExtended
//
//  Created Ярослав Стрельников on 20.10.2020.
//  Copyright © 2020 ___ORGANIZATIONNAME___. All rights reserved.
//
//  Template generated by Juanpe Catalán @JuanpeCMiOS
//

import UIKit
import SwiftyJSON
import RealmSwift
import Alamofire

struct LongPollServer {
    let key: String
    let server: String
    let ts: Int
    let pts: Int
}

class ConversationsInteractor: ConversationsInteractorProtocol {

    weak var presenter: ConversationsPresenterProtocol?
    let conversationServiceInstance = ConversationService.instance
    
    // Получить переписки
    func getConversations(parameters: Alamofire.Parameters) {
        Request.jsonRequest(method: ApiMethod.method(from: .messages, with: ApiMethod.Messages.getConversations), postFields: parameters).done { [weak self] data in
            guard let self = self else { return }
            self.updateDb(by: JSON(data))
            self.presenter?.onFinishRequest()
        }.catch { error in
            self.presenter?.onFinishRequest()
        }
    }
    
    func updateDb(by response: JSON) {
        DispatchQueue.global(qos: .background).async {
            autoreleasepool {
                let realm = try! Realm()
                let items = response["items"].arrayValue
                
                try! realm.write {
                    for item in items {
                        let id = item["conversation"]["peer"]["id"].intValue
                        let fromId = item["last_message"]["from_id"].intValue

                        let profiles = response["profiles"].arrayValue
                        let groups = response["groups"].arrayValue
                        
                        let senderType = self.profile(for: id > 2000000000 ? fromId : id, profiles: profiles, groups: groups)
                        let conversation: Conversation = Conversation(conversation: item["conversation"], lastMessage: item["last_message"], representable: senderType)
                        realm.add(conversation, update: .modified)
                    }
                }
            }
        }
    }
    
    private func profile(for sourseId: Int, profiles: [JSON], groups: [JSON]) -> JSON {
        let profilesOrGroups: [JSON] = sourseId >= 0 ? profiles : groups
        let normalSourseId = sourseId >= 0 ? sourseId : -sourseId
        let profileRepresenatable = profilesOrGroups.first { (myProfileRepresenatable) -> Bool in
            myProfileRepresenatable["id"].intValue == normalSourseId
        }
        return profileRepresenatable!
    }
    
    func getLongPollServer(success: @escaping(_ longPollServer: LongPollServer) -> (Void)) {
        let parameters: Alamofire.Parameters = [Parameter.needPts.rawValue: 1, Parameter.lpVersion.rawValue: 3]
        Request.jsonRequest(method: ApiMethod.method(from: .messages, with: ApiMethod.Messages.getLongPollServer), postFields: parameters).done { data in
            let json = JSON(data)
            success(LongPollServer(key: json["key"].stringValue, server: json["server"].stringValue, ts: json["ts"].intValue, pts: json["pts"].intValue))
        }.catch { error in
            
        }
    }
    
    // Прочитать сообщение
    func readMessage(peerId: Int) {
        let parameters: Alamofire.Parameters = [Parameter.peerId.rawValue: peerId]
        Request.dataRequest(method: ApiMethod.method(from: .messages, with: ApiMethod.Messages.markAsRead), parameters: parameters, hasEventMethod: true).done { [weak self] response in
            guard let self = self else { return }
            switch response {
            case .success:
                DispatchQueue.global(qos: .background).async {
                    autoreleasepool {
                        let realm = try! Realm()
                        guard let conversation = realm.objects(Conversation.self).filter("peerId == %@", peerId).first else { return }
                        try! realm.write {
                            conversation.unreadCount = 0
                            conversation.isMarkedUnread = false
                        }
                    }
                }
                self.presenter?.onEvent(message: "Сообщение прочитано", isError: false)
            case .error(let error):
                self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
            }
        }.catch { error in
            self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
        }
    }
    
    // Пометить непрочитанным
    func markAsUnreadConversation(peerId: Int) {
        let parameters: Alamofire.Parameters = [Parameter.peerId.rawValue: peerId]
        Request.dataRequest(method: ApiMethod.method(from: .messages, with: ApiMethod.Messages.markAsUnread), parameters: parameters, hasEventMethod: true).done { [weak self] response in
            guard let self = self else { return }
            switch response {
            case .success:
                DispatchQueue.global(qos: .background).async {
                    autoreleasepool {
                        let realm = try! Realm()
                        guard let conversation = realm.objects(Conversation.self).filter("peerId == %@", peerId).first else { return }
                        try! realm.write {
                            conversation.isMarkedUnread = true
                        }
                    }
                }
                self.presenter?.onEvent(message: "Сообщение непрочитано", isError: false)
            case .error(let error):
                self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
            }
        }.catch { error in
            self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
        }
    }
    
    // Установить режим уведомления для чата
    func setSilenceMode(peerId: Int, sound: Int) {
        let parameters: Alamofire.Parameters = [Parameter.peerId.rawValue: peerId, Parameter.sound.rawValue: sound, Parameter.time.rawValue: sound == 1 ? 0 : -1]
        Request.dataRequest(method: ApiMethod.method(from: .account, with: ApiMethod.Account.setSilenceMode), parameters: parameters, hasEventMethod: true).done { [weak self] response in
            guard let self = self else { return }
            switch response {
            case .success:
                DispatchQueue.global(qos: .background).async {
                    autoreleasepool {
                        let realm = try! Realm()
                        guard let conversation = realm.objects(Conversation.self).filter("peerId == %@", peerId).first else { return }
                        try! realm.write {
                            conversation.disabledForever = sound == 0
                            conversation.noSound = sound == 0
                        }
                    }
                }
                self.presenter?.onEvent(message: "Уведомления \(sound == 1 ? "включены" : "выключены")", isError: false)
            case .error(let error):
                self.presenter?.onEvent(message: error.localizedDescription, isError: true)
            }
        }.catch { error in
            self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
        }
    }
    
    // Удаление переписки
    func deleteConversation(peerId: Int) {
        let parameters: Alamofire.Parameters = [Parameter.peerId.rawValue: peerId]
        Request.dataRequest(method: ApiMethod.method(from: .messages, with: ApiMethod.Messages.deleteConversation), parameters: parameters).done { [weak self] response in
            guard let self = self else { return }
            switch response {
            case .success:
                DispatchQueue.global(qos: .background).async {
                    autoreleasepool {
                        let realm = try! Realm()
                        guard let conversation = realm.objects(Conversation.self).filter("peerId == %@", peerId).first else { return }
                        try! realm.write {
                            realm.delete(conversation)
                        }
                    }
                }
                self.presenter?.onEvent(message: "Чат удалён", isError: false)
            case .error(let error):
                self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
            }
        }.catch { error in
            self.presenter?.onEvent(message: error.toVK().localizedDescription, isError: true)
        }
    }
}
